**Detecting Sandboxes**

A sandbox is an isolated environment where (malicious) code is executed without affecting anything outside the system. Often, multiple tools are installed to monitor, record and analyze the code’s behaviour.

Check if the directory `C:\Program Files` is present by querying the Registry path `HKLM\\Software\\Microsoft\\Windows\\CurentVersion` . The value can be confirmed by visiting the Registry path within the Registry Editor

![06screenshot01](https://github.com/user-attachments/assets/4ecc7bd9-3e18-4ff6-b463-3965d59bc324)

To open the **`Windows Registry Editor`**, navigate to the **`Start Menu`** on the bottom, select **`Run`**, enter **`regedit`**, and press enter.

![06screenshot02](https://github.com/user-attachments/assets/783e372a-0420-43fa-9fc1-1b148a0a33e7)

This directory is often absent on sandboxes or other virtualised environments, which could indicate that the malware is running in a sandbox.

This is what it looks like in C Language. This function is designed to check the system’s registry for a specified directory path (ProgramFilesDir). This path’s presence or absence helps the malware determine whether it’s running in a typical or virtualised environment.

```c
void registryCheck() {
    const char *registryPath = "HKLM\\Software\\Microsoft\\Windows\\CurrentVersion";
    const char *valueName = "ProgramFilesDir";

    // Prepare the command string for reg.exe
    char command[512];
    snprintf(command, sizeof(command), "reg query \"%s\" /v %s", registryPath, valueName);
    // Run the command
    int result = system(command);
    // Check for successful execution
    if (result == 0) {
        printf("Registry query executed successfully.\n");
    } else {
        fprintf(stderr, "Failed to execute registry query.\n");
    }
}
int main() {
    const char *flag = "[REDACTED]";
    registryCheck();
        return 0;

}
```

**YARA**

Yara is a tool used to identify and classify malware based on patterns in its code. By writing custom rules, analysts can define specific characteristics to look for - such as particular strings, file headers or behaviours - and YARA will scan files or processes to find matches.

```jsx
rule SANDBOXDETECTED
{
    meta:
        description = "Detects the sandbox by querying the registry key for Program Path"
        author = "TryHackMe"
        date = "2024-10-08"
        version = "1.1"

    strings:

    $cmd= "Software\\Microsoft\\Windows\\CurrentVersion\" /v ProgramFilesDir" nocase

    condition:
        $cmd
}
```

A script that executes a YARA detection rule every time a new event is added to the System monitor log. Detects any command that tries to access the registry.

- `strings` section - define variables that include the value to look out for `$cmd`
- `condition` section - define when the rule will match the scanned file. In this case, if any of the specified strings are present

![06screenshot03](https://github.com/user-attachments/assets/913e07e2-e35c-4773-b135-6ce812409af5)

This tool will run on the system and continuously monitor the generated Event Logs. It will alert if it finds any activity or event that indicates the registry mentioned above key is being queried.

![06screenshot04_1](https://github.com/user-attachments/assets/69559ccd-5be8-411a-bdc3-80a6066a0458)

After clicking on the malware, a window popped up, along with the YARA results, showing that Sandbox was detected. 

**Obfuscation**

```jsx
void registryCheck() {
// Encoded PowerShell command to query the registry
    const char *encodedCommand = "RwBlAHQALQBJAHQAZQBtAFAAcgBvAHAAZQByAHQAeQAgAC0AUABhAHQAaAAgACIASABLAEwATQA6AFwAUwBvAGYAdAB3AGEAcgBlAFwATQBpAGMAcgBvAHMAbwBmAHQAXABXAGkAbgBkAG8AdwBzAFwAQwB1AHIAcgBlAG4AdABWAGUAcgBzAGkAbwBuACIAIAAtAE4AYQBtAGUAIABQAHIAbwBnAHIAYQBtAEYAaQBsAGUAcwBEAGkAcgA=";
    // Prepare the PowerShell execution command
    char command[512];
    snprintf(command, sizeof(command), "powershell -EncodedCommand %s", encodedCommand);

    // Run the command
    int result = system(command);

    // Check for successful execution
    if (result == 0) {
        printf("Registry query executed successfully.\n");
    } else {
        fprintf(stderr, "Failed to execute registry query.\n");
    }
}
```

This code does the same thing: query the same registry key to get the information about the Program Data. The only difference is that the query is now encoded using base63, and the code uses the PowerShell to execute the query. 

![06screenshot05](https://github.com/user-attachments/assets/65ff1267-d507-4a76-8ccd-a726c621e52c)

**Floss**

While obfuscation is helpful, we also need to know that there are tools available that extract obfuscated strings from malware binaries. Eg. *Floss,* a powerful tool that functions similarly to the Linux strings tool but is optimized for malware analysis. 

![06screenshot06](https://github.com/user-attachments/assets/3bf4d358-4f51-4497-a654-8ec01e947989)

`floss.exe C:\Tools\Malware\MerryChristmas.exe` - Scans for strings in the binary MerryChristmas.exe. If any hardcoded variables were defined in the malware, Floss should find them

`|` symbol redirects the output of the command in front of it to the input of the command behind it.

`Out-file C:\tools\malstrings.txt` - Save the command results in a file called `malstrings.txt`

![06screenshot07](https://github.com/user-attachments/assets/33b773f1-7b13-4aff-95b3-4b86194ad2af)

The output file of `malstrings.txt` that was generated from Floss.

**Using YARA Rules on Sysmon Logs**

How can YARA rules be used to check Sysmon logs for any artefacts left by malware.

Sysmon, a tool from Microsoft’s Sysinternals suite, continuously monitors and logs system activity across reboots. This Windows service provides detailed event data on process creation, network connections and file changes.

A YARA rule will look for events with `event id 1: Process created` for this to work. 

Apply a custom filter using `EventRecordID` that we can see in the log `YaraMatches.txt` located in `C:\Tools`

![06screenshot08](https://github.com/user-attachments/assets/1218a720-cbde-4e08-a31b-9b2af42cbf3f)

Note down the `Event Record ID value`. Use this value to create a custom filter in the `Windows Event Viewer`. 

`Windows Event Viewer` → `Applications and Services Logs` → `Microsoft` → `Windows` → `Sysmon` → `Operational` ——> `Filter Current Log` → `XML`

![06screenshot09](https://github.com/user-attachments/assets/11206c8d-455c-4c16-a2f7-3d7060250dac)


![06screenshot10](https://github.com/user-attachments/assets/500eba4d-66d7-4b84-b198-fceb655bbe08)

**Event Data (that is valuable)**

- `ParentImage` shows which parent process spawned the cmd.exe process to execute the registry check. Can see it was the malware located in that directory
- `ParentProcessID` and `ProcessId` valuable for follow-up research. Use them to check other logs for related events
    - Process ID of the process that created (or spawned) the current process.
        - Eg. if `cmd.exe` launches `notepad.exe`, the `ParentProcessID` of `notepad.exe` will be the PID of `cmd.exe`
    - Helps track process lineage and understand which processes initiated others.
    - Useful for identifying malicious behaviour such as
        - A script spawning unexpected processes
        - Malware using legitimate processes as parents to blend in
- `User` can help determine which privileges were used to run `cmd.exe` command. Malware could have created a hidden account and used that to run commands
- `CommandLine` shows which command was run in detail, helping to identify malware’s actions.
- `UtcTime` key is essential for creating a time frame for the malware’s operation. This time frame can help focus threat hunting efforts.

(Additional)

**Sysmon Event Id vs Windows Event Viewer ID**

Sysmon Event ID

- Refers to specific types of activities Sysmon monitors
- IDs are specific to Sysmon and provide detailed logging for advanced analysis
- Common Sysmon Event IDs include:
    - 1. Process creation
    - 2. File creation time changes
    - 3. Network connections
    - 11. File creation (from a process

Windows Event Viewer Event ID:

- Refers to event IDs generated by the Windows Event Logging System, which logs broader system and application events (beyond Sysmon)
    - 4624: Successful logon
    - 4663: File accessed
    - 7036: Service status change

**Key Differences**

| **Feature** | **Sysmon (ParentProcessID/ParentID)** | **Windows Event Viewer (Event ID)** |
| --- | --- | --- |
| **Scope** | Advanced process and system monitoring. | General OS, application, and service events. |
| **Focus** | Tracks specific behaviours (e.g., process lineage). | Broader system and security events. |
| **Granularity** | Detailed, including parent-child process relationships. | Higher-level event details. |
| **Customization** | Configurable via Sysmon XML rules. | Fixed events predefined by Windows. |

**Practical Usage in Cybersecurity**

1. **Sysmon ParentProcessID**:
    - Detects anomalies like:
        - Unusual parent processes (e.g., `powershell.exe` spawned by `winword.exe`).
        - Parent-child process chains used in attacks (e.g., phishing payloads).
2. **Windows Event Viewer Event ID**:
    - Correlates with Sysmon logs to provide additional context, such as:
        - Who logged in (Event ID 4624).
        - When files were accessed or modified.

**Obfuscation**

The process of deliberately making something harder to understand, interpret, or reverse-engineer. Often applied to code, data or communication to obscure its intent or make it more challenging for unauthorised individuals to comprehend or misuse.

**Types of Obfuscation**

1. Code obfuscation
    - Used to protect intellectual property of software or to make it harder for attackers to reverse-engineer or analyse the code
    - Techniques include
        - Renaming variables, methods and classes to meaningless names
        - Removing whitespace and comments
        - Using complex and unnecessary logic structures
        - Encoding strings or encrypting parts of the code
            - Original: `if (isUserAuthenticated) { grantAccess(); }`
            - Obfuscated: `if (a) { b(); }`
2. Data Obfuscation
    - Used to obscure sensitive information such as masking personally identifiable information (PII) or database records for testing or analystics
    - Techniques
        - Masking (eg `John Doe` → `J*** D**`)
        - Encryption or hashing
        - Randomisation of data while maintaining patterns
3. Communication obfuscation
    - Used to disguise the purpose or content of network communications, often seen in malware or adversarial tactics
    - Techniques
        - Using encryption to hide malicious payloads
        - Encapsulating commands in benign protocols or formats (hiding commands in image files)
    
    **Detection and Mitigation**
    
    1. **Detection**:
        - Use advanced analysis tools like sandboxing and deobfuscation frameworks.
        - Monitor for suspicious patterns, such as excessive use of encoded or encrypted strings.
        - Leverage behavioural analysis to detect malicious actions despite obfuscation.
    2. **Mitigation**:
        - Enforce strong software security practices to protect against reverse engineering.
        - Use threat intelligence to identify common obfuscation techniques in malware.
        - Implement robust logging and monitoring to track unusual behaviour.
